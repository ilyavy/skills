name: JVM
description: Java Virtual Machine
icon:

levels:
  - number: 1
    links:
      - https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/
    requires:
      - jvm basics
        questions:
          - What is jvm? What it does?
          - What is the name of Oracle's jvm?
          - Are there other jvm implementations?
          - Operations reordering.
      - garbage collection
        link: https://habr.com/ru/post/269621/2/
        questions:
          - What it is?
          - Why do we need it?
          - What the main regions, at which memory is split? Why is that so?
            answer: Eden, Survivor, Tenured (Old Generation); due to the theory that mostly in the average app there are a lot of shortly living objects
          - Which are the main parameters used to estimate GC efficiency?
            answer: pauses, throughtput, consumed resources
          - What are roots?
            answer: references from thread stacks, static members etc.; from them marking is started.
            - which gc is used by default? (none, JVM makes a decision, if none is specified explicitly)
      - garbage first (g1) gc
        link: https://habr.com/ru/post/269863/
        questions:
          - How the memory is split at regions? Why?
          - The main steps at garbage collecting.
            answer: initial mark, concurrent marking, remark, cleanup; minor gc, combined gc
          - Which steps are done concurrently?
          - Advantages and disadvantages.
  - number: 2
    requires:
      - jit
        link: Java Magazine March-April 2016
        questions:
          - Which mode could be used by jvm for just-in-time compilation?
            answer: client, server, combined - remember that it's true for HotSpot
          - In which memory area jvm stores compiled code? How it's cleaned? What will happen if it's full?
            answer: code cache, details in the article by the link
      - serial gc
        link: https://habr.com/ru/post/269707/
          questions:
            - How the memory is split at regions? Why there are 2 survivor spaces?
            - The main steps at garbage collecting.
            - Which steps are done concurrently?
            - Advantages and disadvantages.
      - parallel gc
        link: https://habr.com/ru/post/269707/
          questions:
            - How the memory is split at regions?
            - The main steps at garbage collecting.
            - Which steps are done in parallel?
            - Advantages and disadvantages.
      - concurrent mark and sweep (cms) gc
        link: https://habr.com/ru/post/269863/
          questions:
            - How the memory is split at regions?
            - The main steps at garbage collecting.
            - Which steps are done concurrently?
            - Advantages and disadvantages.
      - memory division
        questions:
          - At which areas the memory is split?
            answer: heap, metaspace, code cache, stack memory (thread mem)
      - memory states
        questions:
          - At which states the memory can be? (allocated, commited)
          - Between each states it can switch? Which jvm component is responsible for memory allocation and freing?
      - reflection
  - number: 3
    requires:
      - visual gc
      - class loading
      - security
      - controlling jvm:
          - -XX:NewRatio
          - -Xms and -Xmx
          - -XX:MetaspaceSize
          - -XX:MaxMetaspaceSize
      - when to use which gc
          - serial gc -> old machines with 1 CPU (don't need a lot of resources, long pauses, heap should be ~ <= 100MB)
          - parallel gc -> many memory, many CPUs; auto adaptation to specified parameters; fragmentation of tenured memory zone; target throughput - 99%
            link: https://habr.com/ru/post/269707/
          - cms gc -> for apps require quick response time (keeps pauses low) and have big amout of long-living data; lower pauses, but lower throughput, consumes more resources; doesn't compact oldgen => high fragmentation => needs ~20% more memory for oldgen; possibility of concurrency mode fail, in which it will switch to serial gc (and will be slow)
          - g1 gc -> for apps needing low and predictable pauses, have big heaps (>4GB), substitution for cms; consumes more resources, lower throughput (target throughput - 90%)
      - profiling:
          - java mission control
          - visualvm
      - graalvm
      - jndi